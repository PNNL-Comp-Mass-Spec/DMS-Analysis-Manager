' This class splits concatenated .dta and .out files from Sequest into their
' original loose, individual file format as generated by 'extract_msn.exe'
'
' -------------------------------------------------------------------------------
' Written by Ken Auberry for the Department of Energy (PNNL, Richland, WA)
' Coding for this class began on 10 October 2007
' Last Modified on 18 October 2007
'
' E-mail: kenneth.auberry@pnl.gov or kauberry@gmail.com
' Website: http://ncrr.pnl.gov/ or http://www.sysbio.org/resources/staff/
' -------------------------------------------------------------------------------
' 
' Licensed under the Apache License, Version 2.0; you may not use this file except
' in compliance with the License.  You may obtain a copy of the License at 
' http://www.apache.org/licenses/LICENSE-2.0
'
' Notice: This computer software was prepared by Battelle Memorial Institute, 
' hereinafter the Contractor, under Contract No. DE-AC05-76RL0 1830 with the 
' Department of Energy (DOE).  All rights in the computer software are reserved 
' by DOE on behalf of the United States Government and the Contractor as 
' provided in the Contract.  NEITHER THE GOVERNMENT NOR THE CONTRACTOR MAKES ANY 
' WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS 
' SOFTWARE.  This notice including this sentence must appear on any copies of 
' this computer software.

'NOTE: Ken's original code plagarized by DA Clark for use in analysis manager - 09/02/2008

Option Strict On

Imports System.Text.RegularExpressions

Public Class clsSplitCattedFiles

#Region "Constants"
	Public Const REGEX_FILE_SEPARATOR As String = "^\s*[=]{5,}\s*\""(?<filename>.+)""\s*[=]{5,}\s*$"
	Public Const REGEX_FILE_NAME_PARTS As String = "^(?<rootname>.+)\.(?<startscan>\d+)\.(?<endscan>\d+)\.(?<chargestate>\d+)\.(?<filetype>.+)"
	Public Const REGEX_DTA_FIRST_LINE As String = "^\s*(?<parentmass>\d+\.\d+)\s+\d+\s+scan\=(?<scannum>\d+)\s+cs\=(?<chargestate>\d+)$"

#End Region
	Private r_FileSeparator As Regex
	Private r_FileNameParts As Regex
	Private r_DTAFirstLine As Regex
	Private m_ResultsFileCount As Integer = 0

	Sub New()

		Me.r_FileSeparator = New Regex(REGEX_FILE_SEPARATOR, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

		Me.r_FileNameParts = New Regex(REGEX_FILE_NAME_PARTS, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

		Me.r_DTAFirstLine = New Regex(REGEX_DTA_FIRST_LINE, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

	End Sub

	Public Function SplitCattedDTAsAndOuts(ByVal datasetName As String, ByVal resultsFolderPath As String) As Boolean
		Dim blnSuccess1 As Boolean
		Dim blnSuccess2 As Boolean
		blnSuccess1 = Me.SplitCattedDTAsOnly(datasetName, resultsFolderPath)
		blnSuccess2 = Me.SplitCattedOutsOnly(datasetName, resultsFolderPath)

		Return blnSuccess1 And blnSuccess2
	End Function

	Public Function SplitCattedDTAsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String) As Boolean
		Return SplitCattedDTAsOnly(datasetName, resultsFolderPath, New Generic.SortedSet(Of String))
	End Function

	Public Function SplitCattedDTAsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String, ByVal lstFilesToSkip As Generic.List(Of String)) As Boolean

		Dim lstFilesToSkipSortedSet As Generic.SortedSet(Of String) = New Generic.SortedSet(Of String)(StringComparer.CurrentCultureIgnoreCase)

		For Each strEntry As String In lstFilesToSkip
			lstFilesToSkipSortedSet.Add(strEntry)
		Next

		Return SplitCattedDTAsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet)
	End Function

	Public Function SplitCattedDTAsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String, ByVal lstFilesToSkip As Generic.SortedSet(Of String)) As Boolean
		Dim fullPath As String = System.IO.Path.Combine(resultsFolderPath, datasetName + "_dta.txt")
		Dim fi As System.IO.FileInfo = New System.IO.FileInfo(fullPath)
		If fi.Exists Then
			If Me.m_ResultsFileCount <= 0 Then
				Me.CountOutFiles(fullPath)
			End If
			Return Me.SplitCattedFile(fullPath, lstFilesToSkip)
		Else
			Return False
		End If
	End Function

	Public Function SplitCattedOutsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String) As Boolean
		Return SplitCattedOutsOnly(datasetName, resultsFolderPath, New Generic.SortedSet(Of String))
	End Function

	Public Function SplitCattedOutsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String, ByVal lstFilesToSkip As Generic.List(Of String)) As Boolean

		Dim lstFilesToSkipSortedSet As Generic.SortedSet(Of String) = New Generic.SortedSet(Of String)(StringComparer.CurrentCultureIgnoreCase)

		For Each strEntry As String In lstFilesToSkip
			lstFilesToSkipSortedSet.Add(strEntry)
		Next

		Return SplitCattedOutsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet)
	End Function

	Public Function SplitCattedOutsOnly(ByVal datasetName As String, ByVal resultsFolderPath As String, ByVal lstFilesToSkip As Generic.SortedSet(Of String)) As Boolean
		Dim fullPath As String = System.IO.Path.Combine(resultsFolderPath, datasetName + "_out.txt")
		Dim fi As System.IO.FileInfo = New System.IO.FileInfo(fullPath)
		If fi.Exists Then
			If Me.m_ResultsFileCount <= 0 Then
				Me.CountOutFiles(fullPath)
			End If
			Return Me.SplitCattedFile(fullPath, lstFilesToSkip)
		Else
			Return False
		End If
	End Function

	''' <summary>
	''' Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
	''' </summary>
	''' <param name="filePath">Source _DTA.txt or _Out.txt file</param>
	''' <remarks></remarks>
	Private Function SplitCattedFile(ByVal filePath As String) As Boolean
		Return SplitCattedFile(filePath, New Generic.SortedSet(Of String))
	End Function

	''' <summary>
	''' Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
	''' </summary>
	''' <param name="filePath">Source _DTA.txt or _Out.txt file</param>
	''' <param name="lstFilesToSkip">Files to skip (full .dta or .out file name)</param>
	''' <remarks></remarks>
	Private Function SplitCattedFile(ByVal filePath As String, ByVal lstFilesToSkip As Generic.SortedSet(Of String)) As Boolean
		Dim s As String
		Dim fileText As Queue(Of String) = New Queue(Of String)
		Dim objFileSepMatch As Match = Nothing
		Dim objFileNameParts As Match = Nothing

		Dim fileCounter As Integer = 0
		Dim fileName As String = String.Empty

		Dim strFileType As String = String.Empty
		Dim resultsFolder As String = System.IO.Path.GetDirectoryName(filePath)

		Dim fiSourceFile As System.IO.FileInfo
		fiSourceFile = New System.IO.FileInfo(filePath)

		If Not fiSourceFile.Exists Then
			Throw New System.IO.FileNotFoundException("Error in SplitCattedFile, File not found: " & filePath)
			Return False
		ElseIf fiSourceFile.Length = 0 Then
			Throw New System.IO.FileNotFoundException("Error in SplitCattedFile, file is empty (zero-bytes): " & filePath)
			Return False
		End If

		Try

			Using srInFile As System.IO.StreamReader = New System.IO.StreamReader(New System.IO.FileStream(filePath, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read))

				While srInFile.Peek > -1
					s = srInFile.ReadLine()

					objFileSepMatch = Me.r_FileSeparator.Match(s)

					If objFileSepMatch.Success Then
						objFileNameParts = r_FileNameParts.Match(objFileSepMatch.Groups("filename").Value)
						If objFileNameParts.Success Then
							strFileType = objFileNameParts.Groups("filetype").Value
						Else
							strFileType = String.Empty
						End If

						If fileCounter > 0 Then
							' Process the data stored in queue fileText, saving to file fileName
							ProcessSplitFile(fileText, fileName, resultsFolder, lstFilesToSkip)
						End If

						If objFileNameParts.Success Then
							With objFileNameParts
								fileName = _
								  .Groups("rootname").Value + "." + _
								  .Groups("startscan").Value.ToString + "." + _
								  .Groups("endscan").Value.ToString + "." + _
								  .Groups("chargestate").Value + "." + _
								  .Groups("filetype").Value
							End With
						Else
							fileName = objFileSepMatch.Groups("filename").Value
						End If

						fileCounter += 1
						fileText.Clear()

						If srInFile.Peek > -1 Then
							s = srInFile.ReadLine()
						Else
							s = String.Empty
						End If

					End If

					If fileCounter > 0 Then
						fileText.Enqueue(s)
					End If

				End While

			End Using

			' Process the data stored in queue fileText, saving to file fileName
			ProcessSplitFile(fileText, fileName, resultsFolder, lstFilesToSkip)

		Catch ex As Exception
			Throw New Exception("Error splitting " & filePath & " in SplitCattedFile: " & ex.Message, ex)
		End Try

		If fileCounter > 0 Then
			Return True
		Else
			Return False
		End If

	End Function

	Private Sub ProcessSplitFile( _
	 ByRef fileText As Queue(Of String), _
	 ByVal exportFileName As String, _
	 ByVal resultsFolder As String, _
	 ByRef lstFilesToSkip As Generic.SortedSet(Of String))

		Dim filetype As String = System.IO.Path.GetExtension(exportFileName).TrimStart("."c)

		Dim lineCounter As Integer = 0

		If lstFilesToSkip.Contains(exportFileName) Then
			' Empty the queue and skip this file
			fileText.Clear()
			Return
		End If

		Using swOutFile As System.IO.StreamWriter = New System.IO.StreamWriter(New System.IO.FileStream(System.IO.Path.Combine(resultsFolder, exportFileName), IO.FileMode.Create, IO.FileAccess.Write, IO.FileShare.Read))

			Dim dtaLineMatch As Match = Nothing
			Dim outputLine As String

			If fileText.Count > 0 AndAlso Me.r_DTAFirstLine.IsMatch(fileText.Peek) Then
				outputLine = fileText.Dequeue

				' See if this line contains the extra information of the form: scan=1000 cs=1
				dtaLineMatch = Me.r_DTAFirstLine.Match(outputLine)
				If dtaLineMatch.Success Then
					' Yes, it has the extra information
					' Only write out the parent mass and charge state for the line
					outputLine = dtaLineMatch.Groups("parentmass").Value + " " + _
					 dtaLineMatch.Groups("chargestate").Value
				Else
					' This code should never be reached since we used Me.r_DTAFirstLine.IsMatch() to check the line in the first place
				End If
				swOutFile.WriteLine(outputLine)
			End If

			While fileText.Count > 0
				outputLine = fileText.Dequeue
				swOutFile.WriteLine(outputLine)
				lineCounter += 1
			End While

		End Using


	End Sub

	Private Function CountOutFiles(ByVal filePath As String) As Integer

		Dim fi As System.IO.FileInfo = New System.IO.FileInfo(filePath)
		Dim s As String
		Dim outFileCount As Integer = 0

		Dim lineEndCharCount As Integer = LineEndCharacterCount(fi)

		Dim r As New Regex("^===*", RegexOptions.Compiled)
		If fi.Exists Then

			Using srInFile As System.IO.StreamReader = New System.IO.StreamReader(New System.IO.FileStream(filePath, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read))
				While srInFile.Peek > -1
					s = srInFile.ReadLine()
					If r.IsMatch(s) Then outFileCount += 1
				End While
			End Using

			Me.m_ResultsFileCount = outFileCount
		End If

		Return outFileCount

	End Function

	''' <summary>
	''' This function reads the input file one byte at a time, looking for the first occurence of Chr(10) or Chr(13) (aka vbCR or VBLF)
	''' When found, the next byte is examined
	''' If the next byte is also Chr(10) or Chr(13), then the line terminator is assumed to be 2 bytes; if not found, then it is assumed to be one byte
	''' </summary>
	''' <param name="fi"></param>
	''' <returns>1 if a one-byte line terminator; 2 if a two-byte line terminator</returns>
	''' <remarks></remarks>
	Private Function LineEndCharacterCount(ByVal fi As System.IO.FileInfo) As Integer
		Dim tr As System.IO.TextReader
		Dim testcode As Integer
		Dim testcode2 As Integer
		Dim counter As Long
		Dim endCount As Integer = 1			' Initially assume a one-byte line terminator

		If (fi.Exists) Then
			tr = fi.OpenText
			For counter = 1 To fi.Length
				testcode = tr.Read()
				If testcode = 10 Or testcode = 13 Then
					testcode2 = tr.Read()
					If testcode2 = 10 Or testcode2 = 13 Then
						endCount = 2
						Exit For
					Else
						endCount = 1
						Exit For
					End If
				End If
			Next

			tr.Close()
		End If

		tr = Nothing
		Return endCount

	End Function

End Class
