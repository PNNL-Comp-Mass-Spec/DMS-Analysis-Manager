' This class splits concatenated .dta and .out files from Sequest into their
' original loose, individual file format as generated by 'extract_msn.exe'
'
' -------------------------------------------------------------------------------
' Written by Ken Auberry for the Department of Energy (PNNL, Richland, WA)
' Coding for this class began on 10 October 2007
' Last Modified on 18 October 2007
'
' E-mail: kenneth.auberry@pnl.gov or kauberry@gmail.com
' Website: http://ncrr.pnl.gov/ or http://www.sysbio.org/resources/staff/
' -------------------------------------------------------------------------------
' 
' Licensed under the Apache License, Version 2.0; you may not use this file except
' in compliance with the License.  You may obtain a copy of the License at 
' http://www.apache.org/licenses/LICENSE-2.0
'
' Notice: This computer software was prepared by Battelle Memorial Institute, 
' hereinafter the Contractor, under Contract No. DE-AC05-76RL0 1830 with the 
' Department of Energy (DOE).  All rights in the computer software are reserved 
' by DOE on behalf of the United States Government and the Contractor as 
' provided in the Contract.  NEITHER THE GOVERNMENT NOR THE CONTRACTOR MAKES ANY 
' WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS 
' SOFTWARE.  This notice including this sentence must appear on any copies of 
' this computer software.

'NOTE: Ken's original code plagarized by DA Clark for use in analysis manager - 09/02/2008

Option Strict On

Imports System.IO
Imports System.Text.RegularExpressions

Public Class clsSplitCattedFiles

#Region "Constants"
    Public Const REGEX_FILE_SEPARATOR As String = "^\s*[=]{5,}\s*\""(?<filename>.+)""\s*[=]{5,}\s*$"
    Public Const REGEX_FILE_NAME_PARTS As String = "^(?<rootname>.+)\.(?<startscan>\d+)\.(?<endscan>\d+)\.(?<chargestate>\d+)\.(?<filetype>.+)"
    Public Const REGEX_DTA_FIRST_LINE As String = "^\s*(?<parentmass>\d+\.\d+)\s+\d+\s+scan\=(?<scannum>\d+)\s+cs\=(?<chargestate>\d+)$"

#End Region
    Private ReadOnly r_FileSeparator As Regex
    Private ReadOnly r_FileNameParts As Regex
    Private ReadOnly r_DTAFirstLine As Regex
    Private m_ResultsFileCount As Integer = 0

    Sub New()

        Me.r_FileSeparator = New Regex(REGEX_FILE_SEPARATOR, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

        Me.r_FileNameParts = New Regex(REGEX_FILE_NAME_PARTS, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

        Me.r_DTAFirstLine = New Regex(REGEX_DTA_FIRST_LINE, RegexOptions.CultureInvariant Or RegexOptions.Compiled)

    End Sub

    Public Function SplitCattedDTAsAndOuts(datasetName As String, resultsFolderPath As String) As Boolean
        Dim blnSuccess1 As Boolean
        Dim blnSuccess2 As Boolean
        blnSuccess1 = Me.SplitCattedDTAsOnly(datasetName, resultsFolderPath)
        blnSuccess2 = Me.SplitCattedOutsOnly(datasetName, resultsFolderPath)

        Return blnSuccess1 And blnSuccess2
    End Function

    Public Function SplitCattedDTAsOnly(datasetName As String, resultsFolderPath As String) As Boolean
        Return SplitCattedDTAsOnly(datasetName, resultsFolderPath, New SortedSet(Of String))
    End Function

    Public Function SplitCattedDTAsOnly(datasetName As String, resultsFolderPath As String, lstFilesToSkip As List(Of String)) As Boolean

        Dim lstFilesToSkipSortedSet As SortedSet(Of String) = New SortedSet(Of String)(StringComparer.CurrentCultureIgnoreCase)

        For Each strEntry As String In lstFilesToSkip
            lstFilesToSkipSortedSet.Add(strEntry)
        Next

        Return SplitCattedDTAsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet)
    End Function

    Public Function SplitCattedDTAsOnly(datasetName As String, resultsFolderPath As String, lstFilesToSkip As SortedSet(Of String)) As Boolean
        Dim fullPath As String = Path.Combine(resultsFolderPath, datasetName + "_dta.txt")
        Dim fi As FileInfo = New FileInfo(fullPath)
        If fi.Exists Then
            If Me.m_ResultsFileCount <= 0 Then
                CountOutFiles(fullPath)
            End If
            Return Me.SplitCattedFile(fullPath, lstFilesToSkip)
        Else
            Return False
        End If
    End Function

    Public Function SplitCattedOutsOnly(datasetName As String, resultsFolderPath As String) As Boolean
        Return SplitCattedOutsOnly(datasetName, resultsFolderPath, New SortedSet(Of String))
    End Function

    Public Function SplitCattedOutsOnly(datasetName As String, resultsFolderPath As String, lstFilesToSkip As List(Of String)) As Boolean

        Dim lstFilesToSkipSortedSet As SortedSet(Of String) = New SortedSet(Of String)(StringComparer.CurrentCultureIgnoreCase)

        For Each strEntry As String In lstFilesToSkip
            lstFilesToSkipSortedSet.Add(strEntry)
        Next

        Return SplitCattedOutsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet)
    End Function

    Public Function SplitCattedOutsOnly(datasetName As String, resultsFolderPath As String, lstFilesToSkip As SortedSet(Of String)) As Boolean
        Dim fullPath As String = Path.Combine(resultsFolderPath, datasetName + "_out.txt")
        Dim fi As FileInfo = New FileInfo(fullPath)
        If fi.Exists Then
            If Me.m_ResultsFileCount <= 0 Then
                CountOutFiles(fullPath)
            End If
            Return Me.SplitCattedFile(fullPath, lstFilesToSkip)
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
    ''' </summary>
    ''' <param name="filePath">Source _DTA.txt or _Out.txt file</param>
    ''' <remarks></remarks>
    Private Function SplitCattedFile(filePath As String) As Boolean
        Return SplitCattedFile(filePath, New SortedSet(Of String))
    End Function

    ''' <summary>
    ''' Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
    ''' </summary>
    ''' <param name="filePath">Source _DTA.txt or _Out.txt file</param>
    ''' <param name="lstFilesToSkip">Files to skip (full .dta or .out file name)</param>
    ''' <remarks></remarks>
    Private Function SplitCattedFile(filePath As String, lstFilesToSkip As SortedSet(Of String)) As Boolean
        Dim s As String
        Dim fileText As Queue(Of String) = New Queue(Of String)
        Dim objFileSepMatch As Match
        Dim objFileNameParts As Match

        Dim fileCounter As Integer = 0
        Dim fileName As String = String.Empty

        Dim resultsFolder As String = Path.GetDirectoryName(filePath)

        Dim fiSourceFile As FileInfo
        fiSourceFile = New FileInfo(filePath)

        If Not fiSourceFile.Exists Then
            Throw New FileNotFoundException("Error in SplitCattedFile, File not found: " & filePath)
        ElseIf fiSourceFile.Length = 0 Then
            Throw New FileNotFoundException("Error in SplitCattedFile, file is empty (zero-bytes): " & filePath)
        End If

        Try

            Using srInFile As StreamReader = New StreamReader(New FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))

                While Not srInfile.EndOfStream
                    s = srInFile.ReadLine()

                    objFileSepMatch = Me.r_FileSeparator.Match(s)

                    If objFileSepMatch.Success Then
                        objFileNameParts = r_FileNameParts.Match(objFileSepMatch.Groups("filename").Value)

                        If fileCounter > 0 Then
                            ' Process the data stored in queue fileText, saving to file fileName
                            ProcessSplitFile(fileText, fileName, resultsFolder, lstFilesToSkip)
                        End If

                        If objFileNameParts.Success Then
                            With objFileNameParts
                                fileName =
                                  .Groups("rootname").Value + "." +
                                  .Groups("startscan").Value.ToString + "." +
                                  .Groups("endscan").Value.ToString + "." +
                                  .Groups("chargestate").Value + "." +
                                  .Groups("filetype").Value
                            End With
                        Else
                            fileName = objFileSepMatch.Groups("filename").Value
                        End If

                        fileCounter += 1
                        fileText.Clear()

                        If Not srInFile.EndOfStream Then
                            s = srInFile.ReadLine()
                        Else
                            s = String.Empty
                        End If

                    End If

                    If fileCounter > 0 Then
                        fileText.Enqueue(s)
                    End If

                End While

            End Using

            ' Process the data stored in queue fileText, saving to file fileName
            ProcessSplitFile(fileText, fileName, resultsFolder, lstFilesToSkip)

        Catch ex As Exception
            Throw New Exception("Error splitting " & filePath & " in SplitCattedFile: " & ex.Message, ex)
        End Try

        If fileCounter > 0 Then
            Return True
        Else
            Return False
        End If

    End Function

    Private Sub ProcessSplitFile(
     ByRef fileText As Queue(Of String),
     exportFileName As String,
     resultsFolder As String,
     ByRef lstFilesToSkip As SortedSet(Of String))

        If lstFilesToSkip.Contains(exportFileName) Then
            ' Empty the queue and skip this file
            fileText.Clear()
            Return
        End If

        Using swOutFile As StreamWriter = New StreamWriter(New FileStream(Path.Combine(resultsFolder, exportFileName), FileMode.Create, FileAccess.Write, FileShare.Read))

            Dim dtaLineMatch As Match
            Dim outputLine As String

            If fileText.Count > 0 AndAlso Me.r_DTAFirstLine.IsMatch(fileText.Peek) Then
                outputLine = fileText.Dequeue

                ' See if this line contains the extra information of the form: scan=1000 cs=1
                dtaLineMatch = Me.r_DTAFirstLine.Match(outputLine)
                If dtaLineMatch.Success Then
                    ' Yes, it has the extra information
                    ' Only write out the parent mass and charge state for the line
                    outputLine = dtaLineMatch.Groups("parentmass").Value + " " +
                                 dtaLineMatch.Groups("chargestate").Value
                Else
                    ' This code should never be reached since we used Me.r_DTAFirstLine.IsMatch() to check the line in the first place
                End If
                swOutFile.WriteLine(outputLine)
            End If

            While fileText.Count > 0
                outputLine = fileText.Dequeue
                swOutFile.WriteLine(outputLine)
            End While

        End Using


    End Sub

    Private Sub CountOutFiles(filePath As String)

        Dim fi As FileInfo = New FileInfo(filePath)
        Dim s As String
        Dim outFileCount As Integer = 0

        Dim r As New Regex("^===*", RegexOptions.Compiled)
        If fi.Exists Then

            Using srInFile As StreamReader = New StreamReader(New FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                While Not srInfile.EndOfStream
                    s = srInFile.ReadLine()
                    If r.IsMatch(s) Then outFileCount += 1
                End While
            End Using

            m_ResultsFileCount = outFileCount
        End If

    End Sub

    ''' <summary>
    ''' This function reads the input file one byte at a time, looking for the first occurence of Chr(10) or Chr(13) (aka vbCR or VBLF)
    ''' When found, the next byte is examined
    ''' If the next byte is also Chr(10) or Chr(13), then the line terminator is assumed to be 2 bytes; if not found, then it is assumed to be one byte
    ''' </summary>
    ''' <param name="fi"></param>
    ''' <returns>1 if a one-byte line terminator; 2 if a two-byte line terminator</returns>
    ''' <remarks></remarks>
    Private Function LineEndCharacterCount(fi As FileInfo) As Integer
        Dim tr As TextReader
        Dim testcode As Integer
        Dim testcode2 As Integer
        Dim endCount As Integer = 1         ' Initially assume a one-byte line terminator

        If (fi.Exists) Then
            tr = fi.OpenText
            For counter = 1 To fi.Length
                testcode = tr.Read()
                If testcode = 10 Or testcode = 13 Then
                    testcode2 = tr.Read()
                    If testcode2 = 10 Or testcode2 = 13 Then
                        endCount = 2
                        Exit For
                    Else
                        endCount = 1
                        Exit For
                    End If
                End If
            Next

            tr.Close()
        End If

        Return endCount

    End Function

End Class
