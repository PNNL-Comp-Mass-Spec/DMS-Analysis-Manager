using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace AnalysisManagerBase
{
    /// <summary>
    /// This class splits concatenated .dta and .out files from Sequest into their
    /// original loose, individual file format as generated by 'extract_msn.exe'
    /// </summary>
    public class clsSplitCattedFiles
    {

        #region "Constants"

        private const string REGEX_FILE_SEPARATOR = @"^\s*[=]{5,}\s*\""(?<filename>.+)""\s*[=]{5,}\s*$";
        private const string REGEX_FILE_NAME_PARTS = @"^(?<rootname>.+)\.(?<startscan>\d+)\.(?<endscan>\d+)\.(?<chargestate>\d+)\.(?<filetype>.+)";

        private const string REGEX_DTA_FIRST_LINE = @"^\s*(?<parentmass>\d+\.\d+)\s+\d+\s+scan\=(?<scannum>\d+)\s+cs\=(?<chargestate>\d+)$";

        #endregion

        private readonly Regex mFileSeparator;
        private readonly Regex mFileNameParts;
        private readonly Regex mDTAFirstLine;

        private int m_ResultsFileCount;

        /// <summary>
        /// Constructor
        /// </summary>
        public clsSplitCattedFiles()
        {
            mFileSeparator = new Regex(REGEX_FILE_SEPARATOR, RegexOptions.CultureInvariant | RegexOptions.Compiled);

            mFileNameParts = new Regex(REGEX_FILE_NAME_PARTS, RegexOptions.CultureInvariant | RegexOptions.Compiled);

            mDTAFirstLine = new Regex(REGEX_DTA_FIRST_LINE, RegexOptions.CultureInvariant | RegexOptions.Compiled);

        }

        /// <summary>
        /// Call SplitCattedDTAsOnly and SplitCattedOutsOnly for the given dataset
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <returns></returns>
        public bool SplitCattedDTAsAndOuts(string datasetName, string resultsFolderPath)
        {
            var success1 = SplitCattedDTAsOnly(datasetName, resultsFolderPath);
            var success2 = SplitCattedOutsOnly(datasetName, resultsFolderPath);

            return success1 && success2;
        }

        /// <summary>
        /// Split a _dta.txt file into individual .dta files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <returns></returns>
        public bool SplitCattedDTAsOnly(string datasetName, string resultsFolderPath)
        {
            return SplitCattedDTAsOnly(datasetName, resultsFolderPath, new SortedSet<string>());
        }

        /// <summary>
        /// Split a _dta.txt file into individual .dta files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <param name="lstFilesToSkip">Files to skip</param>
        /// <returns></returns>
        public bool SplitCattedDTAsOnly(string datasetName, string resultsFolderPath, List<string> lstFilesToSkip)
        {

            var lstFilesToSkipSortedSet = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var entry in lstFilesToSkip)
            {
                lstFilesToSkipSortedSet.Add(entry);
            }

            return SplitCattedDTAsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet);
        }

        /// <summary>
        /// Split a _dta.txt file into individual .dta files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <param name="lstFilesToSkip">Files to skip</param>
        /// <returns></returns>
        public bool SplitCattedDTAsOnly(string datasetName, string resultsFolderPath, SortedSet<string> lstFilesToSkip)
        {
            var fullPath = Path.Combine(resultsFolderPath, datasetName + "_dta.txt");
            var fi = new FileInfo(fullPath);
            if (fi.Exists)
            {
                if (m_ResultsFileCount <= 0)
                {
                    CountOutFiles(fullPath);
                }
                return SplitCattedFile(fullPath, lstFilesToSkip);
            }

            return false;
        }

        /// <summary>
        /// Split an _out.txt file into individual .out files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <returns></returns>
        public bool SplitCattedOutsOnly(string datasetName, string resultsFolderPath)
        {
            return SplitCattedOutsOnly(datasetName, resultsFolderPath, new SortedSet<string>());
        }

        /// <summary>
        /// Split an _out.txt file into individual .out files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <param name="lstFilesToSkip">Files to skip</param>
        /// <returns></returns>
        public bool SplitCattedOutsOnly(string datasetName, string resultsFolderPath, List<string> lstFilesToSkip)
        {

            var lstFilesToSkipSortedSet = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var entry in lstFilesToSkip)
            {
                lstFilesToSkipSortedSet.Add(entry);
            }

            return SplitCattedOutsOnly(datasetName, resultsFolderPath, lstFilesToSkipSortedSet);
        }

        /// <summary>
        /// Split an _out.txt file into individual .out files
        /// </summary>
        /// <param name="datasetName"></param>
        /// <param name="resultsFolderPath"></param>
        /// <param name="lstFilesToSkip">Files to skip</param>
        /// <returns></returns>
        public bool SplitCattedOutsOnly(string datasetName, string resultsFolderPath, SortedSet<string> lstFilesToSkip)
        {
            var fullPath = Path.Combine(resultsFolderPath, datasetName + "_out.txt");
            var fi = new FileInfo(fullPath);
            if (fi.Exists)
            {
                if (m_ResultsFileCount <= 0)
                {
                    CountOutFiles(fullPath);
                }
                return SplitCattedFile(fullPath, lstFilesToSkip);
            }

            return false;
        }

        /// <summary>
        /// Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
        /// </summary>
        /// <param name="filePath">Source _DTA.txt or _Out.txt file</param>
        /// <param name="lstFilesToSkip">Files to skip (full .dta or .out file name)</param>
        /// <remarks></remarks>
        private bool SplitCattedFile(string filePath, SortedSet<string> lstFilesToSkip)
        {
            var fileText = new Queue<string>();
            var fileCounter = 0;
            var fileName = string.Empty;

            var resultsFolder = Path.GetDirectoryName(filePath);

            var fiSourceFile = new FileInfo(filePath);

            if (!fiSourceFile.Exists)
            {
                throw new FileNotFoundException("Error in SplitCattedFile, File not found: " + filePath);
            }

            if (fiSourceFile.Length == 0)
            {
                throw new FileNotFoundException("Error in SplitCattedFile, file is empty (zero-bytes): " + filePath);
            }

            try
            {
                using (var srInFile = new StreamReader(new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read)))
                {

                    while (!srInFile.EndOfStream)
                    {
                        var s = srInFile.ReadLine();
                        if (s == null)
                            continue;

                        var fileSepMatch = mFileSeparator.Match(s);

                        if (fileSepMatch.Success)
                        {
                            var fileNameParts = mFileNameParts.Match(fileSepMatch.Groups["filename"].Value);

                            if (fileCounter > 0)
                            {
                                // Process the data stored in queue fileText, saving to file fileName
                                ProcessSplitFile(ref fileText, fileName, resultsFolder, ref lstFilesToSkip);
                            }

                            if (fileNameParts.Success)
                            {
                                fileName = fileNameParts.Groups["rootname"].Value + "." +
                                    fileNameParts.Groups["startscan"].Value + "." +
                                    fileNameParts.Groups["endscan"].Value + "." +
                                    fileNameParts.Groups["chargestate"].Value + "." +
                                    fileNameParts.Groups["filetype"].Value;
                            }
                            else
                            {
                                fileName = fileSepMatch.Groups["filename"].Value;
                            }

                            fileCounter += 1;
                            fileText.Clear();

                            if (!srInFile.EndOfStream)
                            {
                                s = srInFile.ReadLine();
                            }
                            else
                            {
                                s = string.Empty;
                            }

                        }

                        if (fileCounter > 0)
                        {
                            fileText.Enqueue(s);
                        }

                    }

                }

                // Process the data stored in queue fileText, saving to file fileName
                ProcessSplitFile(ref fileText, fileName, resultsFolder, ref lstFilesToSkip);

            }
            catch (Exception ex)
            {
                throw new Exception("Error splitting " + filePath + " in SplitCattedFile: " + ex.Message, ex);
            }

            if (fileCounter > 0)
            {
                return true;
            }

            return false;
        }

        private void ProcessSplitFile(ref Queue<string> fileText, string exportFileName, string resultsFolder, ref SortedSet<string> lstFilesToSkip)
        {
            if (lstFilesToSkip.Contains(exportFileName))
            {
                // Empty the queue and skip this file
                fileText.Clear();
                return;
            }

            using (var swOutFile = new StreamWriter(new FileStream(Path.Combine(resultsFolder, exportFileName), FileMode.Create, FileAccess.Write, FileShare.Read)))
            {

                if (fileText.Count > 0 && mDTAFirstLine.IsMatch(fileText.Peek()))
                {
                    var outputLine = fileText.Dequeue();

                    // See if this line contains the extra information of the form: scan=1000 cs=1
                    var dtaLineMatch = mDTAFirstLine.Match(outputLine);
                    if (dtaLineMatch.Success)
                    {
                        // Yes, it has the extra information
                        // Only write out the parent mass and charge state for the line
                        outputLine = dtaLineMatch.Groups["parentmass"].Value + " " + dtaLineMatch.Groups["chargestate"].Value;
                    }
                    else
                    {
                        // This code should never be reached since we used Me.r_DTAFirstLine.IsMatch() to check the line in the first place
                    }
                    swOutFile.WriteLine(outputLine);
                }

                while (fileText.Count > 0)
                {
                    var outputLine = fileText.Dequeue();
                    swOutFile.WriteLine(outputLine);
                }

            }


        }

        private void CountOutFiles(string filePath)
        {
            var fi = new FileInfo(filePath);
            var outFileCount = 0;

            var r = new Regex("^===*", RegexOptions.Compiled);

            if (!fi.Exists)
            {
                m_ResultsFileCount = 0;
                return;
            }

            using (var srInFile = new StreamReader(new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                while (!srInFile.EndOfStream)
                {
                    var s = srInFile.ReadLine();
                    if (s != null && r.IsMatch(s))
                        outFileCount += 1;
                }
            }

            m_ResultsFileCount = outFileCount;
        }

    }
}
