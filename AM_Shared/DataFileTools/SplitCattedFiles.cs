using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using AnalysisManagerBase.AnalysisTool;

namespace AnalysisManagerBase.DataFileTools
{
    /// <summary>
    /// This class splits concatenated .dta and .out files from Sequest into their
    /// original loose, individual file format as generated by 'extract_msn.exe'
    /// </summary>
    public class SplitCattedFiles
    {
        private const string REGEX_FILE_SEPARATOR = @"^\s*[=]{5,}\s*\""(?<filename>.+)""\s*[=]{5,}\s*$";
        private const string REGEX_FILE_NAME_PARTS = @"^(?<rootname>.+)\.(?<startscan>\d+)\.(?<endscan>\d+)\.(?<chargestate>\d+)\.(?<filetype>.+)";

        private const string REGEX_DTA_FIRST_LINE = @"^\s*(?<parentmass>\d+\.\d+)\s+\d+\s+scan\=(?<scannum>\d+)\s+cs\=(?<chargestate>\d+)$";

        private readonly Regex mFileSeparator;
        private readonly Regex mFileNameParts;
        private readonly Regex mDTAFirstLine;

        private int mResultsFileCount;

        /// <summary>
        /// Constructor
        /// </summary>
        public SplitCattedFiles()
        {
            mFileSeparator = new Regex(REGEX_FILE_SEPARATOR, RegexOptions.CultureInvariant | RegexOptions.Compiled);

            mFileNameParts = new Regex(REGEX_FILE_NAME_PARTS, RegexOptions.CultureInvariant | RegexOptions.Compiled);

            mDTAFirstLine = new Regex(REGEX_DTA_FIRST_LINE, RegexOptions.CultureInvariant | RegexOptions.Compiled);
        }

        /// <summary>
        /// Split a _dta.txt file into individual .dta files
        /// </summary>
        /// <param name="datasetName">Dataset name</param>
        /// <param name="resultsFolderPath">Results folder path</param>
        /// <param name="filesToSkip">Files to skip</param>
        public bool SplitCattedDTAsOnly(string datasetName, string resultsFolderPath, SortedSet<string> filesToSkip)
        {
            var cdtaFilePath = Path.Combine(resultsFolderPath, datasetName + AnalysisResources.CDTA_EXTENSION);
            var cdtaFile = new FileInfo(cdtaFilePath);

            if (cdtaFile.Exists)
            {
                if (mResultsFileCount <= 0)
                {
                    CountFilesInConcatenatedTextFile(cdtaFilePath);
                }
                return SplitCattedFile(cdtaFilePath, filesToSkip);
            }

            return false;
        }

        /// <summary>
        /// Split an _out.txt file into individual .out files
        /// </summary>
        /// <param name="datasetName">Dataset name</param>
        /// <param name="resultsFolderPath">Results folder path</param>
        public bool SplitCattedOutsOnly(string datasetName, string resultsFolderPath)
        {
            var outFilePath = Path.Combine(resultsFolderPath, datasetName + "_out.txt");
            var outFile = new FileInfo(outFilePath);

            if (!outFile.Exists)
                return false;

            if (mResultsFileCount <= 0)
            {
                CountFilesInConcatenatedTextFile(outFilePath);
            }

            var filesToSkip = new SortedSet<string>();

            return SplitCattedFile(outFilePath, filesToSkip);
        }

        /// <summary>
        /// Split a concatenated _DTA.txt or _Out.txt file into individual .dta or .out files
        /// </summary>
        /// <param name="filePath">Source _DTA.txt or _Out.txt file</param>
        /// <param name="filesToSkip">Files to skip (full .dta or .out file name)</param>
        private bool SplitCattedFile(string filePath, SortedSet<string> filesToSkip)
        {
            var fileText = new Queue<string>();
            var fileCounter = 0;
            var fileName = string.Empty;

            var resultsFolder = Path.GetDirectoryName(filePath);

            var sourceFile = new FileInfo(filePath);

            if (!sourceFile.Exists)
            {
                throw new FileNotFoundException("Error in SplitCattedFile, File not found: " + filePath);
            }

            if (sourceFile.Length == 0)
            {
                throw new FileNotFoundException("Error in SplitCattedFile, file is empty (zero-bytes): " + filePath);
            }

            try
            {
                using (var reader = new StreamReader(new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read)))
                {
                    while (!reader.EndOfStream)
                    {
                        var dataLine = reader.ReadLine();

                        if (dataLine == null)
                            continue;

                        var fileSepMatch = mFileSeparator.Match(dataLine);

                        if (fileSepMatch.Success)
                        {
                            var fileNameParts = mFileNameParts.Match(fileSepMatch.Groups["filename"].Value);

                            if (fileCounter > 0)
                            {
                                // Process the data stored in queue fileText, saving to fileName
                                ProcessSplitFile(ref fileText, fileName, resultsFolder, ref filesToSkip);
                            }

                            if (fileNameParts.Success)
                            {
                                fileName = fileNameParts.Groups["rootname"].Value + "." +
                                    fileNameParts.Groups["startscan"].Value + "." +
                                    fileNameParts.Groups["endscan"].Value + "." +
                                    fileNameParts.Groups["chargestate"].Value + "." +
                                    fileNameParts.Groups["filetype"].Value;
                            }
                            else
                            {
                                fileName = fileSepMatch.Groups["filename"].Value;
                            }

                            fileCounter++;
                            fileText.Clear();

                            if (!reader.EndOfStream)
                            {
                                dataLine = reader.ReadLine();
                            }
                            else
                            {
                                dataLine = string.Empty;
                            }
                        }

                        if (fileCounter > 0)
                        {
                            fileText.Enqueue(dataLine);
                        }
                    }
                }

                // Process the data stored in queue fileText, saving to fileName
                ProcessSplitFile(ref fileText, fileName, resultsFolder, ref filesToSkip);
            }
            catch (Exception ex)
            {
                throw new Exception("Error splitting " + filePath + " in SplitCattedFile: " + ex.Message, ex);
            }

            return fileCounter > 0;
        }

        private void ProcessSplitFile(ref Queue<string> fileText, string exportFileName, string resultsFolder, ref SortedSet<string> filesToSkip)
        {
            if (filesToSkip.Contains(exportFileName))
            {
                // Empty the queue and skip this file
                fileText.Clear();
                return;
            }

            using var writer = new StreamWriter(new FileStream(Path.Combine(resultsFolder, exportFileName), FileMode.Create, FileAccess.Write, FileShare.Read));

            if (fileText.Count > 0 && mDTAFirstLine.IsMatch(fileText.Peek()))
            {
                var outputLine = fileText.Dequeue();

                // See if this line contains the extra information of the form: scan=1000 cs=1
                var dtaLineMatch = mDTAFirstLine.Match(outputLine);

                if (dtaLineMatch.Success)
                {
                    // Yes, it has the extra information
                    // Only write out the parent mass and charge state for the line
                    outputLine = dtaLineMatch.Groups["parentmass"].Value + " " + dtaLineMatch.Groups["chargestate"].Value;
                }
                else
                {
                    // This code should never be reached since we used Me.r_DTAFirstLine.IsMatch() to check the line in the first place
                }
                writer.WriteLine(outputLine);
            }

            while (fileText.Count > 0)
            {
                var outputLine = fileText.Dequeue();
                writer.WriteLine(outputLine);
            }
        }

        /// <summary>
        /// Count the number of .out or .dta files in a _out.txt or _dta.txt file
        /// </summary>
        /// <param name="concatenatedFilePath">_dta.txt file path</param>
        private void CountFilesInConcatenatedTextFile(string concatenatedFilePath)
        {
            var concatenatedFile = new FileInfo(concatenatedFilePath);
            var fileCount = 0;

            var reOutFileSepMatcher = new Regex("^===*", RegexOptions.Compiled);

            if (!concatenatedFile.Exists)
            {
                mResultsFileCount = 0;
                return;
            }

            using (var reader = new StreamReader(new FileStream(concatenatedFile.FullName, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                while (!reader.EndOfStream)
                {
                    var dataLine = reader.ReadLine();

                    if (dataLine != null && reOutFileSepMatcher.IsMatch(dataLine))
                        fileCount++;
                }
            }

            mResultsFileCount = fileCount;
        }
    }
}
